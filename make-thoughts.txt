How's THIS for a makefile replacement:
A makefile's purpose is to define a DAG of dependancies, each with rules
attached.  Now, Lispy languages are good at definding trees, which are rather
like DAG's.  What if we turned
rule: depend1 depend2
	buildthingy

depend1: depend2 depend3
	build1

depend2: depend3
	build2

depend3:
	build3

with

(rule (buildthingy)
   (depend1 (build1)
      (depend2 (build2) 
         (depend3 (build3)))
      (depend3) (build3)))

Well, because it's massively redundant.  It's a tree, not a DAG.  Hmph.
Still, just a better, more programatically-inclined syntax would probably be a
good idea.

(rule (depend1 depend2)
   buildfunc)

(depend1 (depend2 depend3)
   build1)

(depend2 (depend3)
   build2)

(depend3 ()
   build3)
   
If you had a syntax like that with real variables and functions and strings
and lists, and a program/utility to take a bunch of rules and automatically
make a dependancy tree and a operation tree.

For instance, you have a C project with 3 .c files, 3 .h files, and 1 of each
generated by bison.  You could do:

;; definitions
;; Scheme, pretty much.  ! is a shell-out.

(define c-comp "/usr/bin/gcc")
(define c-opts '("-Wall" "-I."))

(define bison "/usr/bin/bison")
(define bison-opts '("-v"))

(define build-c (opts file)
   (! c-comp c-opts opts file))

(define build-bison (opts file)
   (! bison bison-opts opts file))

;; rules
;; :"foo" is a depeandency that makes sure the file "foo" exists and is up
;; to date. filedeps is a special variable that is all the file-dependancies
;; of the rule.

(start-point (foo1 foo2 build-parser)
   (build-c "foo1.o" "foo2.o" "parser.o")) ;; Unideal...

(foo1 (:"foo1.c" :"foo1.h")
   (build-c filedeps))

(foo2 (:"foo2.c" :"foo2.h")
   (build-c filedeps))

(build-parser (parser)
   (build-c "parser.c" "parser.h"))

(parser (:"foo.y")
   (build-bison filedeps))



Okay.  It sorta works, for simple things.  However, it is different from make,
and perhaps not as flexible.  What make does is defines a bunch of FILES that
must exist for each rule, and define more rules that each create those files.
A rule and a file are more or less the same thing.

This just creates a bunch of rules and lets you define what rule is executed
before what rule.  It makes no guarentees that the FILES these rules depend on
exist.  That's up to the programmer.

Hmmm.  What if we do it differently.  Each rule has three parts: a list of
files it depends on, a list of files it generates, and a list of operations to
do so.  That'd be more or less like make, really, but oh well.  >_>

Fing is, either it has to be language-dependant... No!  NONONONO!!!!  I have
it!  If you can define real functions and variables, then you can define
"libraries" of functionality for each language!  So the C "library" would have
a bunch of functions that know how C files are compiled, the OCaml library
would know how to compile OCaml, and so on...

Hmmmmmmm.  Fing is, a function can only compile a file, not define the
structure of one or more rules.  You were compiling OCaml, you could do

; (rule (inputs) (outputs) operations)
(rule (foo.ml) (foo.cmo foo.cmi) 
   (build-ocaml opts filedeps -o fileresults))

but you still have to write all the rules out, you couldn't just say "here's
the program, here are the .ml files needed to build it, please do so".  You
could write a program that could do that, but then it wouldn't necessarily
know about .mly files, preprocessors, .c files that have to be built into it,
and all sorts of other weird shit.  You need a make-ish system where you can
define the precise rules to do that.

So the problem is, how do we make it so you MAY define the rule from scratch,
but do not HAVE to?

The idea of language-specific libraries is a good one.  However, instead of
functions that just build things, how about templates or macros that define
rules?  That has some real potential.  If you do, for instance:

(macro link-ocaml ({foo}.cmo {foo.cmi}) (a.out)
   (link-ocaml ocaml-link-opts filedeps -o a.out))

(macro make-ocaml ({foo}.ml) ({foo}.cmo {foo}.cmi)
   (compile-ocaml ocaml-opts filedeps)
   (apply-macro link-ocaml *))

(apply-macro make-ocaml *)

That'd take all the files ending in .ml and compile them to bytecode, then
link them into a program.  It wouldn't work right 'cause it doesn't actually
do dependancy checking, but you get the idea.
